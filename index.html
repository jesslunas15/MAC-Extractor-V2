<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Excel Processor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #downloadContainer { display:flex; flex-wrap:wrap; gap:10px; justify-content:flex-start; margin-bottom:20px; }
    .download-btn { background:#007bff; color:white; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; text-decoration:none; }
    .download-btn:hover { background:#0056b3; }
    table { border-collapse:collapse; margin-top:10px; width:100%; }
    th, td { border:1px solid #ccc; padding:6px; text-align:left; }
    th { background:#f5f5f5; }
  </style>
</head>
<body>
  <h2>Excel Processor</h2>
  <input type="file" id="upload" multiple accept=".xlsx,.xls,.zip" />
  <div id="downloadContainer"></div>
  <div id="output"></div>

  <script>
    document.getElementById('upload').addEventListener('change', handleFiles);

    async function handleFiles(event) {
      const files = Array.from(event.target.files);
      const downloadContainer = document.getElementById('downloadContainer');
      const output = document.getElementById('output');
      downloadContainer.innerHTML = "";
      output.innerHTML = "";

      if (!files.length) return;

      for (const file of files) {
        let allRows = [];
        let baseName = "";

        if (/\.zip$/i.test(file.name)) {
          const zip = await JSZip.loadAsync(file);
          const excelFiles = Object.keys(zip.files).filter(fn => fn.match(/\.(xlsx|xls)$/i));
          for (const filename of excelFiles) {
            const content = await zip.files[filename].async("blob");
            const rows = await extractRows(content);
            allRows = allRows.concat(rows);
          }
          baseName = file.name.replace(/\.zip$/i, "");
        } else if (/\.(xlsx|xls)$/i.test(file.name)) {
          const rows = await extractRows(file);
          allRows = allRows.concat(rows);
          baseName = file.name.replace(/\.(xlsx|xls)$/i, "");
        }

        if (allRows.length) {
          await processRows(allRows, baseName);
        }
      }
    }

    async function extractRows(fileBlob) {
      const data = await fileBlob.arrayBuffer();
      const workbook = XLSX.read(data, { type: "array" });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      return XLSX.utils.sheet_to_json(sheet, { header: 1, defval: "" });
    }

    async function processRows(rows, baseName) {
      const macRegex = /^[0-9A-F]{2}([:-][0-9A-F]{2}){5}$/i;
      let firstMacIndex = -1;
      for (let i = 0; i < Math.min(10, rows.length); i++) {
        const cell = rows[i] && rows[i][1];
        if (typeof cell === "string" && macRegex.test(cell.trim())) {
          firstMacIndex = i;
          break;
        }
      }
      const dataStart = firstMacIndex >= 0 ? firstMacIndex : 1;
      const dataRows = rows.slice(dataStart).filter(r => Array.isArray(r));

      const mapped = dataRows.map(r => {
        const col2 = (r[1] !== undefined && r[1] !== null) ? String(r[1]).trim() : "";
        const col5 = (r[4] !== undefined && r[4] !== null) ? String(r[4]).trim() : "";
        return [col2, col5];
      }).filter(([col2, col5]) => col2 && col5);

      const groups = {};
      mapped.forEach(([mac, ap]) => {
        if (!groups[ap]) groups[ap] = new Set();
        groups[ap].add(mac); // prevent duplicates inside this AP group
      });

      // keep only AP names containing "free"
      const filteredGroups = Object.keys(groups)
        .filter(k => k.toLowerCase().includes("free"))
        .sort()
        .reduce((o, k) => { o[k] = Array.from(groups[k]); return o; }, {});

      // Display table
      const table = document.createElement("table");
      const thead = document.createElement("thead");
      const trHead = document.createElement("tr");
      ["Access Point", "MAC Address"].forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        trHead.appendChild(th);
      });
      thead.appendChild(trHead);
      table.appendChild(thead);

      const tbody = document.createElement("tbody");
      for (const apName of Object.keys(filteredGroups)) {
        filteredGroups[apName].forEach(mac => {
          const tr = document.createElement("tr");
          const tdAP = document.createElement("td");
          tdAP.textContent = apName;
          const tdMAC = document.createElement("td");
          tdMAC.textContent = mac;
          tr.appendChild(tdAP);
          tr.appendChild(tdMAC);
          tbody.appendChild(tr);
        });
      }
      table.appendChild(tbody);
      document.getElementById("output").appendChild(table);

      // Excel output
      const wsData = [["Access Point", "MAC Address"]];
      for (const apName of Object.keys(filteredGroups)) {
        filteredGroups[apName].forEach(mac => wsData.push([apName, mac]));
      }

      const ws = XLSX.utils.aoa_to_sheet(wsData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Processed");
      const wbout = XLSX.write(wb, { bookType: "xlsx", type: "array" });
      const blob = new Blob([wbout], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });

      const url = URL.createObjectURL(blob);
      const btn = document.createElement("a");
      btn.href = url;
      btn.download = baseName + "_processed.xlsx";
      btn.textContent = btn.download;
      btn.className = "download-btn";
      btn.addEventListener('click', () => setTimeout(() => URL.revokeObjectURL(url), 1500));
      document.getElementById("downloadContainer").appendChild(btn);
    }
  </script>
</body>
</html>
